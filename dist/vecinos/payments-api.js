"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const express_1 = __importDefault(require("express"));
const router = express_1.default.Router();
// ✅ Definición temporal de la tabla posTransactions (hasta que arregles el schema)
// Puedes descomentar esto si necesitas estas rutas funcionando:
/*
export const posTransactions = pgTable('pos_transactions', {
  id: serial('id').primaryKey(),
  partnerId: integer('partner_id').notNull(),
  amount: decimal('amount', { precision: 10, scale: 2 }).notNull(),
  transactionId: varchar('transaction_id', { length: 255 }).unique().notNull(),
  status: varchar('status', { length: 50 }).default('pending'),
  createdAt: timestamp('created_at').defaultNow(),
  updatedAt: timestamp('updated_at').defaultNow()
});
*/
// ✅ RUTAS COMENTADAS TEMPORALMENTE - descomenta cuando arregles el schema
/*
router.post('/create', async (req, res) => {
  try {
    const { partnerId, amount } = req.body;
    
    const transactionId = uuidv4();
    
    const [transaction] = await db.insert(posTransactions).values({
      partnerId,
      amount: amount.toString(),
      transactionId,
      status: 'pending'
    }).returning();
    
    res.json({
      success: true,
      transaction,
      transactionId
    });
    
  } catch (error) {
    console.error('Error creating POS transaction:', error);
    res.status(500).json({
      success: false,
      message: 'Error creating transaction'
    });
  }
});

router.get('/status/:transactionId', async (req, res) => {
  try {
    const { transactionId } = req.params;
    
    const [transaction] = await db
      .select()
      .from(posTransactions)
      .where(eq(posTransactions.transactionId, transactionId))
      .limit(1);
    
    if (!transaction) {
      return res.status(404).json({
        success: false,
        message: 'Transaction not found'
      });
    }
    
    res.json({
      success: true,
      transaction
    });
    
  } catch (error) {
    console.error('Error getting transaction status:', error);
    res.status(500).json({
      success: false,
      message: 'Error getting transaction status'
    });
  }
});

router.post('/confirm/:transactionId', async (req, res) => {
  try {
    const { transactionId } = req.params;
    
    const [updatedTransaction] = await db
      .update(posTransactions)
      .set({
        status: 'completed',
        updatedAt: new Date()
      })
      .where(eq(posTransactions.transactionId, transactionId))
      .returning();
    
    if (!updatedTransaction) {
      return res.status(404).json({
        success: false,
        message: 'Transaction not found'
      });
    }
    
    res.json({
      success: true,
      transaction: updatedTransaction
    });
    
  } catch (error) {
    console.error('Error confirming transaction:', error);
    res.status(500).json({
      success: false,
      message: 'Error confirming transaction'
    });
  }
});
*/
// ✅ Ruta temporal para verificar que el módulo funciona
router.get('/health', (req, res) => {
    res.json({
        success: true,
        message: 'Payments API is working',
        timestamp: new Date().toISOString()
    });
});
exports.default = router;
